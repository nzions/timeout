
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>timeout: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">allmytails/contrib/timeout/timeout.go (83.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "io"
        "os"
        "os/exec"
        "os/signal"
        "strconv"
        "strings"
        "syscall"
        "time"
)

// Config holds all the configuration for the timeout command
type Config struct {
        KillAfter      string
        SignalName     string
        PreserveStatus bool
        Foreground     bool
        Verbose        bool
        Help           bool
        Version        bool

        // For testing
        Stdout io.Writer
        Stderr io.Writer
        Stdin  io.Reader
}

// Result holds the result of running a command
type Result struct {
        ExitCode int
        Error    error
}

func usage(w io.Writer, progName string) <span class="cov8" title="1">{
        fmt.Fprintf(w, "Usage: %s [OPTION] DURATION COMMAND [ARG]...\n", progName)
        fmt.Fprintf(w, "  or:  %s [OPTION]\n", progName)
        fmt.Fprintf(w, "Start COMMAND, and kill it if still running after DURATION.\n\n")
        fmt.Fprintf(w, "Options:\n")
        flag.CommandLine.SetOutput(w)
        flag.PrintDefaults()
        fmt.Fprintf(w, "\nDURATION is a floating point number with an optional suffix:\n")
        fmt.Fprintf(w, "'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for days.\n")
        fmt.Fprintf(w, "A duration of 0 disables the associated timeout.\n\n")
        fmt.Fprintf(w, "If the command times out, and --preserve-status is not set, then exit with\n")
        fmt.Fprintf(w, "status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n")
        fmt.Fprintf(w, "is specified, send the TERM signal upon timeout.  The TERM signal kills\n")
        fmt.Fprintf(w, "any process that does not block or catch that signal.  It may be necessary\n")
        fmt.Fprintf(w, "to use the KILL (9) signal, since this signal cannot be caught, in which\n")
        fmt.Fprintf(w, "case the exit status is 128+9 rather than 124.\n")
}</span>

func parseDuration(s string) (time.Duration, error) <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("empty duration")
        }</span>

        // Handle suffixes
        <span class="cov8" title="1">var multiplier time.Duration = time.Second
        suffix := s[len(s)-1:]

        switch suffix </span>{
        case "s":<span class="cov8" title="1">
                s = s[:len(s)-1]
                multiplier = time.Second</span>
        case "m":<span class="cov8" title="1">
                s = s[:len(s)-1]
                multiplier = time.Minute</span>
        case "h":<span class="cov8" title="1">
                s = s[:len(s)-1]
                multiplier = time.Hour</span>
        case "d":<span class="cov8" title="1">
                s = s[:len(s)-1]
                multiplier = 24 * time.Hour</span>
        default:<span class="cov8" title="1">
                // No suffix, assume seconds
                multiplier = time.Second</span>
        }

        // Parse the numeric part
        <span class="cov8" title="1">if f, err := strconv.ParseFloat(s, 64); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span> else<span class="cov8" title="1"> {
                return time.Duration(f * float64(multiplier)), nil
        }</span>
}

func parseSignal(s string) (syscall.Signal, error) <span class="cov8" title="1">{
        // Handle numeric signals
        if num, err := strconv.Atoi(s); err == nil </span><span class="cov8" title="1">{
                return syscall.Signal(num), nil
        }</span>

        // Handle named signals (with or without SIG prefix)
        <span class="cov8" title="1">s = strings.ToUpper(s)
        if !strings.HasPrefix(s, "SIG") </span><span class="cov8" title="1">{
                s = "SIG" + s
        }</span>

        <span class="cov8" title="1">signals := map[string]syscall.Signal{
                "SIGTERM": syscall.SIGTERM,
                "SIGKILL": syscall.SIGKILL,
                "SIGINT":  syscall.SIGINT,
                "SIGQUIT": syscall.SIGQUIT,
                "SIGHUP":  syscall.SIGHUP,
                "SIGUSR1": syscall.SIGUSR1,
                "SIGUSR2": syscall.SIGUSR2,
                "SIGPIPE": syscall.SIGPIPE,
                "SIGALRM": syscall.SIGALRM,
                "SIGCHLD": syscall.SIGCHLD,
                "SIGCONT": syscall.SIGCONT,
                "SIGSTOP": syscall.SIGSTOP,
                "SIGTSTP": syscall.SIGTSTP,
                "SIGTTIN": syscall.SIGTTIN,
                "SIGTTOU": syscall.SIGTTOU,
        }

        if sig, ok := signals[s]; ok </span><span class="cov8" title="1">{
                return sig, nil
        }</span>

        <span class="cov8" title="1">return 0, fmt.Errorf("invalid signal: %s", s)</span>
}

// runTimeout executes the timeout logic and returns the result
func runTimeout(config Config, args []string) Result <span class="cov8" title="1">{
        if config.Help </span><span class="cov8" title="1">{
                usage(config.Stderr, "timeout")
                return Result{ExitCode: 0}
        }</span>

        <span class="cov8" title="1">if config.Version </span><span class="cov8" title="1">{
                fmt.Fprintln(config.Stdout, "timeout (GNU coreutils compatible) 1.0")
                return Result{ExitCode: 0}
        }</span>

        <span class="cov8" title="1">if len(args) &lt; 2 </span><span class="cov8" title="1">{
                fmt.Fprintf(config.Stderr, "timeout: missing operand\n")
                fmt.Fprintf(config.Stderr, "Try 'timeout --help' for more information.\n")
                return Result{ExitCode: 125}
        }</span>

        // Parse timeout
        <span class="cov8" title="1">timeoutDuration, err := parseDuration(args[0])
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(config.Stderr, "timeout: invalid time interval '%s'\n", args[0])
                return Result{ExitCode: 125}
        }</span>

        // Get command and args
        <span class="cov8" title="1">command := args[1]
        cmdArgs := args[2:]

        // Parse signal
        timeoutSignal, err := parseSignal(config.SignalName)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(config.Stderr, "timeout: %v\n", err)
                return Result{ExitCode: 125}
        }</span>

        // Parse kill-after duration
        <span class="cov8" title="1">var killAfterDuration time.Duration
        if config.KillAfter != "" </span><span class="cov8" title="1">{
                killAfterDuration, err = parseDuration(config.KillAfter)
                if err != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(config.Stderr, "timeout: invalid time interval '%s'\n", config.KillAfter)
                        return Result{ExitCode: 125}
                }</span>
        }

        // Create context with timeout (0 duration means no timeout)
        <span class="cov8" title="1">var ctx context.Context
        var cancel context.CancelFunc
        if timeoutDuration &gt; 0 </span><span class="cov8" title="1">{
                ctx, cancel = context.WithTimeout(context.Background(), timeoutDuration)
                defer cancel()
        }</span> else<span class="cov8" title="1"> {
                ctx = context.Background()
        }</span>

        // Create command
        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, command, cmdArgs...)
        cmd.Stdout = config.Stdout
        cmd.Stderr = config.Stderr
        cmd.Stdin = config.Stdin

        // Handle interrupt signals to clean up properly
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
        defer signal.Stop(sigChan)

        // Start the command
        if err := cmd.Start(); err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(config.Stderr, "Error starting command: %v\n", err)
                return Result{ExitCode: 1, Error: err}
        }</span>

        // Wait for either completion or signal
        <span class="cov8" title="1">done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                done &lt;- cmd.Wait()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                // Timeout occurred
                if config.Verbose </span><span class="cov8" title="1">{
                        fmt.Fprintf(config.Stderr, "timeout: sending signal %s to command '%s'\n", config.SignalName, command)
                }</span>

                <span class="cov8" title="1">if cmd.Process != nil </span><span class="cov8" title="1">{
                        // Send the specified signal
                        if err := cmd.Process.Signal(timeoutSignal); err != nil &amp;&amp; config.Verbose </span><span class="cov0" title="0">{
                                fmt.Fprintf(config.Stderr, "timeout: failed to send signal: %v\n", err)
                        }</span>

                        // If kill-after is specified, wait and then send KILL
                        <span class="cov8" title="1">if config.KillAfter != "" &amp;&amp; killAfterDuration &gt; 0 </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-time.After(killAfterDuration):<span class="cov0" title="0">
                                        if config.Verbose </span><span class="cov0" title="0">{
                                                fmt.Fprintf(config.Stderr, "timeout: sending signal KILL to command '%s'\n", command)
                                        }</span>
                                        <span class="cov0" title="0">cmd.Process.Signal(syscall.SIGKILL)</span>
                                case &lt;-done:<span class="cov0" title="0"></span>
                                        // Process exited before kill-after timeout
                                }
                        }
                }

                // Wait for process to finish
                <span class="cov8" title="1">&lt;-done

                if config.PreserveStatus </span><span class="cov0" title="0">{
                        // Exit with command's status (if available)
                        if cmd.ProcessState != nil </span><span class="cov0" title="0">{
                                return Result{ExitCode: cmd.ProcessState.ExitCode()}
                        }</span>
                        <span class="cov0" title="0">return Result{ExitCode: 1}</span>
                } else<span class="cov8" title="1"> {
                        // Standard timeout exit code
                        if timeoutSignal == syscall.SIGKILL </span><span class="cov8" title="1">{
                                return Result{ExitCode: 128 + 9} // 128 + SIGKILL
                        }</span>
                        <span class="cov8" title="1">return Result{ExitCode: 124}</span>
                }
        case sig := &lt;-sigChan:<span class="cov0" title="0">
                // Signal received
                if cmd.Process != nil </span><span class="cov0" title="0">{
                        cmd.Process.Signal(sig)
                }</span>
                <span class="cov0" title="0">&lt;-done                       // Wait for process to finish
                return Result{ExitCode: 130}</span> // Standard interrupt exit code
        case err := &lt;-done:<span class="cov8" title="1">
                // Command completed
                if err != nil </span><span class="cov8" title="1">{
                        if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                                return Result{ExitCode: exitError.ExitCode()}
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(config.Stderr, "timeout: %v\n", err)
                        return Result{ExitCode: 1, Error: err}</span>
                }
                <span class="cov8" title="1">return Result{ExitCode: 0}</span>
        }
}

var (
        killAfter      = flag.String("kill-after", "", "also send a KILL signal if command is still running this long after the initial signal was sent")
        signalName     = flag.String("signal", "TERM", "specify the signal to be sent on timeout")
        preserveStatus = flag.Bool("preserve-status", false, "exit with the same status as COMMAND, even when the command times out")
        foreground     = flag.Bool("foreground", false, "when not running timeout directly from a shell prompt, allow COMMAND to read from the TTY and get TTY signals")
        verbose        = flag.Bool("verbose", false, "diagnose to stderr any signal sent upon timeout")
        help           = flag.Bool("help", false, "display this help and exit")
        version        = flag.Bool("version", false, "output version information and exit")
)

func main() <span class="cov0" title="0">{
        flag.Usage = func() </span><span class="cov0" title="0">{ usage(os.Stderr, os.Args[0]) }</span>
        <span class="cov0" title="0">flag.Parse()

        config := Config{
                KillAfter:      *killAfter,
                SignalName:     *signalName,
                PreserveStatus: *preserveStatus,
                Foreground:     *foreground,
                Verbose:        *verbose,
                Help:           *help,
                Version:        *version,
                Stdout:         os.Stdout,
                Stderr:         os.Stderr,
                Stdin:          os.Stdin,
        }

        result := runTimeout(config, flag.Args())
        os.Exit(result.ExitCode)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
